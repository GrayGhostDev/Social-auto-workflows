apiVersion: v1
kind: ConfigMap
metadata:
  name: vector-store-config
  namespace: mcp
data:
  postgresql.conf: |
    # PostgreSQL configuration for pgvector
    shared_buffers = 2GB
    effective_cache_size = 6GB
    maintenance_work_mem = 512MB
    checkpoint_completion_target = 0.9
    wal_buffers = 16MB
    default_statistics_target = 100
    random_page_cost = 1.1
    effective_io_concurrency = 200
    work_mem = 10485kB
    min_wal_size = 1GB
    max_wal_size = 4GB
    max_worker_processes = 8
    max_parallel_workers_per_gather = 4
    max_parallel_workers = 8
    max_parallel_maintenance_workers = 4
    
    # pgvector specific
    shared_preload_libraries = 'pgvector'
    
    # Connection settings
    max_connections = 200
    
    # Logging
    log_statement = 'all'
    log_duration = on
    log_min_duration_statement = 100
    
    # SSL
    ssl = on
    ssl_cert_file = '/etc/ssl/certs/server.crt'
    ssl_key_file = '/etc/ssl/private/server.key'
    
  init.sql: |
    -- Create pgvector extension
    CREATE EXTENSION IF NOT EXISTS vector;
    
    -- Create schemas
    CREATE SCHEMA IF NOT EXISTS embeddings;
    CREATE SCHEMA IF NOT EXISTS memory;
    
    -- Embedding storage table
    CREATE TABLE IF NOT EXISTS embeddings.documents (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      agent_id VARCHAR(50) NOT NULL,
      content TEXT NOT NULL,
      embedding vector(1536) NOT NULL,
      metadata JSONB DEFAULT '{}',
      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );
    
    -- Create HNSW index for fast similarity search
    CREATE INDEX IF NOT EXISTS idx_documents_embedding 
    ON embeddings.documents 
    USING hnsw (embedding vector_l2_ops)
    WITH (m = 16, ef_construction = 64);
    
    -- Agent memory table
    CREATE TABLE IF NOT EXISTS memory.agent_sessions (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      agent_id VARCHAR(50) NOT NULL,
      session_id VARCHAR(100) NOT NULL,
      memory_type VARCHAR(20) CHECK (memory_type IN ('short', 'long', 'working')),
      content JSONB NOT NULL,
      embedding vector(1536),
      relevance_score FLOAT DEFAULT 1.0,
      access_count INTEGER DEFAULT 0,
      last_accessed TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
      expires_at TIMESTAMP WITH TIME ZONE,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
      UNIQUE(agent_id, session_id, memory_type)
    );
    
    -- A/B test results
    CREATE TABLE IF NOT EXISTS memory.ab_tests (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      test_id VARCHAR(100) NOT NULL,
      variant VARCHAR(10) NOT NULL,
      agent_id VARCHAR(50) NOT NULL,
      metric_name VARCHAR(50) NOT NULL,
      metric_value FLOAT NOT NULL,
      metadata JSONB DEFAULT '{}',
      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );
    
    -- Content deduplication
    CREATE TABLE IF NOT EXISTS embeddings.content_hashes (
      hash VARCHAR(64) PRIMARY KEY,
      content_id UUID NOT NULL,
      agent_id VARCHAR(50) NOT NULL,
      first_seen TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
      occurrence_count INTEGER DEFAULT 1,
      FOREIGN KEY (content_id) REFERENCES embeddings.documents(id)
    );
    
    -- Create indexes
    CREATE INDEX idx_sessions_agent_session ON memory.agent_sessions(agent_id, session_id);
    CREATE INDEX idx_sessions_expires ON memory.agent_sessions(expires_at) WHERE expires_at IS NOT NULL;
    CREATE INDEX idx_ab_tests_lookup ON memory.ab_tests(test_id, variant, agent_id);
    CREATE INDEX idx_content_hashes_agent ON embeddings.content_hashes(agent_id, first_seen);
    
    -- Grants
    GRANT ALL PRIVILEGES ON SCHEMA embeddings TO mcp_user;
    GRANT ALL PRIVILEGES ON SCHEMA memory TO mcp_user;
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA embeddings TO mcp_user;
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA memory TO mcp_user;
---
apiVersion: v1
kind: Secret
metadata:
  name: vector-store-credentials
  namespace: mcp
type: Opaque
data:
  POSTGRES_USER: bWNwX3VzZXI=  # mcp_user
  POSTGRES_PASSWORD: # Will be generated by Vault
  POSTGRES_DB: dmVjdG9yX3N0b3Jl  # vector_store
  PATRONI_SUPERUSER_USERNAME: cG9zdGdyZXM=  # postgres
  PATRONI_SUPERUSER_PASSWORD: # Will be generated by Vault
  PATRONI_REPLICATION_USERNAME: cmVwbGljYXRvcg==  # replicator
  PATRONI_REPLICATION_PASSWORD: # Will be generated by Vault
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: vector-store
  namespace: mcp
  labels:
    app: vector-store
    component: database
spec:
  serviceName: vector-store
  replicas: 2
  selector:
    matchLabels:
      app: vector-store
  template:
    metadata:
      labels:
        app: vector-store
        component: database
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9187"
        vault.hashicorp.com/agent-inject: "true"
        vault.hashicorp.com/role: "mcp-vector-store"
        vault.hashicorp.com/agent-inject-secret-db-password: "secret/data/mcp/vector_store_password"
    spec:
      serviceAccountName: vector-store
      securityContext:
        fsGroup: 999
        runAsUser: 999
        runAsNonRoot: true
      containers:
      - name: postgres
        image: postgres:15-pgvector
        ports:
        - name: postgres
          containerPort: 5432
          protocol: TCP
        env:
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: vector-store-credentials
              key: POSTGRES_USER
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: vector-store-credentials
              key: POSTGRES_PASSWORD
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              name: vector-store-credentials
              key: POSTGRES_DB
        resources:
          requests:
            cpu: 1
            memory: 4Gi
          limits:
            cpu: 4
            memory: 8Gi
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
        - name: config
          mountPath: /etc/postgresql
          readOnly: true
        - name: init-scripts
          mountPath: /docker-entrypoint-initdb.d
          readOnly: true
        readinessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - mcp_user
            - -d
            - vector_store
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - mcp_user
            - -d
            - vector_store
          initialDelaySeconds: 60
          periodSeconds: 30
      - name: patroni
        image: patroni/patroni:3.0-p1
        ports:
        - name: patroni
          containerPort: 8008
          protocol: TCP
        env:
        - name: PATRONI_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: PATRONI_KUBERNETES_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: PATRONI_KUBERNETES_LABELS
          value: "{app: vector-store}"
        - name: PATRONI_SUPERUSER_USERNAME
          valueFrom:
            secretKeyRef:
              name: vector-store-credentials
              key: PATRONI_SUPERUSER_USERNAME
        - name: PATRONI_SUPERUSER_PASSWORD
          valueFrom:
            secretKeyRef:
              name: vector-store-credentials
              key: PATRONI_SUPERUSER_PASSWORD
        - name: PATRONI_REPLICATION_USERNAME
          valueFrom:
            secretKeyRef:
              name: vector-store-credentials
              key: PATRONI_REPLICATION_USERNAME
        - name: PATRONI_REPLICATION_PASSWORD
          valueFrom:
            secretKeyRef:
              name: vector-store-credentials
              key: PATRONI_REPLICATION_PASSWORD
        - name: PATRONI_SCOPE
          value: "vector-store"
        - name: PATRONI_POSTGRESQL_DATA_DIR
          value: "/var/lib/postgresql/data/pgdata"
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 512Mi
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
      - name: exporter
        image: prometheuscommunity/postgres-exporter:v0.13.2
        ports:
        - name: metrics
          containerPort: 9187
          protocol: TCP
        env:
        - name: DATA_SOURCE_NAME
          value: "postgresql://mcp_user:$(POSTGRES_PASSWORD)@localhost:5432/vector_store?sslmode=require"
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 256Mi
      volumes:
      - name: config
        configMap:
          name: vector-store-config
          items:
          - key: postgresql.conf
            path: postgresql.conf
      - name: init-scripts
        configMap:
          name: vector-store-config
          items:
          - key: init.sql
            path: 01-init.sql
  volumeClaimTemplates:
  - metadata:
      name: data
      labels:
        app: vector-store
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: gp3-encrypted
      resources:
        requests:
          storage: 100Gi
---
apiVersion: v1
kind: Service
metadata:
  name: vector-store
  namespace: mcp
  labels:
    app: vector-store
spec:
  type: ClusterIP
  clusterIP: None  # Headless service for StatefulSet
  ports:
  - name: postgres
    port: 5432
    targetPort: postgres
    protocol: TCP
  - name: patroni
    port: 8008
    targetPort: patroni
    protocol: TCP
  selector:
    app: vector-store
---
apiVersion: v1
kind: Service
metadata:
  name: vector-store-primary
  namespace: mcp
  labels:
    app: vector-store
    role: primary
spec:
  type: ClusterIP
  ports:
  - name: postgres
    port: 5432
    targetPort: postgres
    protocol: TCP
  selector:
    app: vector-store
    role: master  # Patroni sets this label on primary
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vector-store
  namespace: mcp
  labels:
    app: vector-store
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vector-store
  namespace: mcp
rules:
- apiGroups: [""]
  resources: ["pods", "endpoints"]
  verbs: ["get", "list", "watch", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vector-store
  namespace: mcp
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vector-store
subjects:
- kind: ServiceAccount
  name: vector-store
  namespace: mcp
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: vector-store-network-policy
  namespace: mcp
spec:
  podSelector:
    matchLabels:
      app: vector-store
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: agent-runner
    ports:
    - protocol: TCP
      port: 5432
  - from:
    - podSelector:
        matchLabels:
          app: vector-store
    ports:
    - protocol: TCP
      port: 5432
    - protocol: TCP
      port: 8008
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: vector-store
    ports:
    - protocol: TCP
      port: 5432
    - protocol: TCP
      port: 8008
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: UDP
      port: 53
  - to:
    - namespaceSelector:
        matchLabels:
          name: vault
    ports:
    - protocol: TCP
      port: 8200